{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MCP Java SDK","text":"<p>Java SDK for the Model Context Protocol enables standardized integration between AI models and tools.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MCP Client and MCP Server implementations supporting:<ul> <li>Protocol version compatibility negotiation with multiple protocol versions</li> <li>Tools discovery, execution, list change notifications, and structured output with schema validation</li> <li>Resources management with URI templates</li> <li>Roots list management and notifications</li> <li>Prompts handling and management</li> <li>Sampling support for AI model interactions</li> <li>Elicitation support for requesting user input from servers</li> <li>Completions for argument autocompletion suggestions</li> <li>Progress - progress notifications for tracking long-running operations</li> <li>Logging - structured logging with configurable severity levels</li> </ul> </li> <li>Multiple transport implementations:<ul> <li>Default transports (included in core <code>mcp</code> module, no external web frameworks required):<ul> <li>STDIO-based transport for process-based communication</li> <li>Java HttpClient-based SSE client transport for HTTP SSE Client-side streaming</li> <li>Servlet-based SSE server transport for HTTP SSE Server streaming</li> <li>Streamable HTTP transport for efficient bidirectional communication (client and server)</li> </ul> </li> <li>Optional Spring-based transports (convenience if using Spring Framework):<ul> <li>WebFlux SSE client and server transports for reactive HTTP streaming</li> <li>WebFlux Streamable HTTP server transport</li> <li>WebMVC SSE server transport for servlet-based HTTP streaming</li> <li>WebMVC Streamable HTTP server transport</li> <li>WebMVC Stateless server transport</li> </ul> </li> </ul> </li> <li>Supports Synchronous and Asynchronous programming paradigms</li> <li>Pluggable JSON serialization (Jackson 2.x and Jackson 3.x)</li> <li>Pluggable authorization hooks for server security</li> <li>DNS rebinding protection with Host/Origin header validation</li> </ul> <p>Tip</p> <p>The core <code>io.modelcontextprotocol.sdk:mcp</code> module provides default STDIO, SSE, and Streamable HTTP client and server transport implementations without requiring external web frameworks.</p> <p>Spring-specific transports are available as optional dependencies for convenience when using the MCP Client Boot Starter and MCP Server Boot Starter. Also consider the MCP Annotations and MCP Security.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The SDK follows a layered architecture with clear separation of concerns:</p> <p></p> <ul> <li>Client/Server Layer (McpClient/McpServer): Both use McpSession for sync/async operations,   with McpClient handling client-side protocol operations and McpServer managing server-side protocol operations.</li> <li>Session Layer (McpSession): Manages communication patterns and state.</li> <li>Transport Layer (McpTransport): Handles JSON-RPC message serialization/deserialization via:<ul> <li>StdioTransport (stdin/stdout) in the core module</li> <li>HTTP SSE transports in dedicated transport modules (Java HttpClient, Spring WebFlux, Spring WebMVC)</li> <li>Streamable HTTP transports for efficient bidirectional communication</li> </ul> </li> </ul> <p>The MCP Client is a key component in the Model Context Protocol (MCP) architecture, responsible for establishing and managing connections with MCP servers. It implements the client-side of the protocol.</p> <p></p> <p>The MCP Server is a foundational component in the Model Context Protocol (MCP) architecture that provides tools, resources, and capabilities to clients. It implements the server-side of the protocol.</p> <p></p> <p>Key Interactions:</p> <ul> <li>Client/Server Initialization: Transport setup, protocol compatibility check, capability negotiation, and implementation details exchange.</li> <li>Message Flow: JSON-RPC message handling with validation, type-safe response processing, and error handling.</li> <li>Resource Management: Resource discovery, URI template-based access, subscription system, and content retrieval.</li> </ul>"},{"location":"#module-structure","title":"Module Structure","text":"<p>The SDK is organized into modules to separate concerns and allow adopters to bring in only what they need:</p> Module Artifact ID Purpose <code>mcp-bom</code> <code>mcp-bom</code> Bill of Materials for dependency management <code>mcp-core</code> <code>mcp-core</code> Core reference implementation (STDIO, JDK HttpClient, Servlet, Streamable HTTP) <code>mcp-json-jackson2</code> <code>mcp-json-jackson2</code> Jackson 2.x JSON serialization implementation <code>mcp-json-jackson3</code> <code>mcp-json-jackson3</code> Jackson 3.x JSON serialization implementation <code>mcp</code> <code>mcp</code> Convenience bundle (<code>mcp-core</code> + <code>mcp-json-jackson3</code>) <code>mcp-test</code> <code>mcp-test</code> Shared testing utilities and integration tests <code>mcp-spring-webflux</code> <code>mcp-spring-webflux</code> Spring WebFlux integration (SSE and Streamable HTTP) <code>mcp-spring-webmvc</code> <code>mcp-spring-webmvc</code> Spring WebMVC integration (SSE and Streamable HTTP) <p>Tip</p> <p>A minimal adopter may depend only on <code>mcp</code> (core + Jackson 3), while a Spring-based application can add <code>mcp-spring-webflux</code> or <code>mcp-spring-webmvc</code> for deeper framework integration.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p> Quickstart</p> <p>Get started with dependencies and BOM configuration.</p> <p> Quickstart</p> </li> <li> <p> MCP Client</p> <p>Learn how to create and configure MCP clients.</p> <p> Client</p> </li> <li> <p> MCP Server</p> <p>Learn how to implement and configure MCP servers.</p> <p> Server</p> </li> <li> <p> GitHub</p> <p>View the source code and contribute.</p> <p> Repository</p> </li> </ul>"},{"location":"client/","title":"MCP Client","text":"<p>The MCP Client is a key component in the Model Context Protocol (MCP) architecture, responsible for establishing and managing connections with MCP servers. It implements the client-side of the protocol, handling:</p> <ul> <li>Protocol version negotiation to ensure compatibility with servers</li> <li>Capability negotiation to determine available features</li> <li>Message transport and JSON-RPC communication</li> <li>Tool discovery and execution with optional schema validation</li> <li>Resource access and management</li> <li>Prompt system interactions</li> <li>Optional features like roots management, sampling, and elicitation support</li> <li>Progress tracking for long-running operations</li> </ul> <p>Tip</p> <p>The core <code>io.modelcontextprotocol.sdk:mcp</code> module provides STDIO, SSE, and Streamable HTTP client transport implementations without requiring external web frameworks.</p> <p>Spring-specific transport implementations are available as an optional dependency <code>io.modelcontextprotocol.sdk:mcp-spring-webflux</code> for Spring Framework users.</p> <p>The client provides both synchronous and asynchronous APIs for flexibility in different application contexts.</p> Sync APIAsync API <pre><code>// Create a sync client with custom configuration\nMcpSyncClient client = McpClient.sync(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)       // Enable roots capability\n        .sampling()        // Enable sampling capability\n        .elicitation()     // Enable elicitation capability\n        .build())\n    .sampling(request -&gt; new CreateMessageResult(response))\n    .elicitation(request -&gt; new ElicitResult(ElicitResult.Action.ACCEPT, content))\n    .build();\n\n// Initialize connection\nclient.initialize();\n\n// List available tools\nListToolsResult tools = client.listTools();\n\n// Call a tool\nCallToolResult result = client.callTool(\n    new CallToolRequest(\"calculator\",\n        Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3))\n);\n\n// List and read resources\nListResourcesResult resources = client.listResources();\nReadResourceResult resource = client.readResource(\n    new ReadResourceRequest(\"resource://uri\")\n);\n\n// List and use prompts\nListPromptsResult prompts = client.listPrompts();\nGetPromptResult prompt = client.getPrompt(\n    new GetPromptRequest(\"greeting\", Map.of(\"name\", \"Spring\"))\n);\n\n// Add/remove roots\nclient.addRoot(new Root(\"file:///path\", \"description\"));\nclient.removeRoot(\"file:///path\");\n\n// Close client\nclient.closeGracefully();\n</code></pre> <pre><code>// Create an async client with custom configuration\nMcpAsyncClient client = McpClient.async(transport)\n    .requestTimeout(Duration.ofSeconds(10))\n    .capabilities(ClientCapabilities.builder()\n        .roots(true)       // Enable roots capability\n        .sampling()        // Enable sampling capability\n        .elicitation()     // Enable elicitation capability\n        .build())\n    .sampling(request -&gt; Mono.just(new CreateMessageResult(response)))\n    .elicitation(request -&gt; Mono.just(new ElicitResult(ElicitResult.Action.ACCEPT, content)))\n    .toolsChangeConsumer(tools -&gt; Mono.fromRunnable(() -&gt; {\n        logger.info(\"Tools updated: {}\", tools);\n    }))\n    .resourcesChangeConsumer(resources -&gt; Mono.fromRunnable(() -&gt; {\n        logger.info(\"Resources updated: {}\", resources);\n    }))\n    .promptsChangeConsumer(prompts -&gt; Mono.fromRunnable(() -&gt; {\n        logger.info(\"Prompts updated: {}\", prompts);\n    }))\n    .progressConsumer(progress -&gt; Mono.fromRunnable(() -&gt; {\n        logger.info(\"Progress: {}\", progress);\n    }))\n    .build();\n\n// Initialize connection and use features\nclient.initialize()\n    .flatMap(initResult -&gt; client.listTools())\n    .flatMap(tools -&gt; {\n        return client.callTool(new CallToolRequest(\n            \"calculator\",\n            Map.of(\"operation\", \"add\", \"a\", 2, \"b\", 3)\n        ));\n    })\n    .flatMap(result -&gt; {\n        return client.listResources()\n            .flatMap(resources -&gt;\n                client.readResource(new ReadResourceRequest(\"resource://uri\"))\n            );\n    })\n    .flatMap(resource -&gt; {\n        return client.listPrompts()\n            .flatMap(prompts -&gt;\n                client.getPrompt(new GetPromptRequest(\n                    \"greeting\",\n                    Map.of(\"name\", \"Spring\")\n                ))\n            );\n    })\n    .flatMap(prompt -&gt; {\n        return client.addRoot(new Root(\"file:///path\", \"description\"))\n            .then(client.removeRoot(\"file:///path\"));\n    })\n    .doFinally(signalType -&gt; {\n        client.closeGracefully().subscribe();\n    })\n    .subscribe();\n</code></pre>"},{"location":"client/#client-transport","title":"Client Transport","text":"<p>The transport layer handles the communication between MCP clients and servers, providing different implementations for various use cases. The client transport manages message serialization, connection establishment, and protocol-specific communication patterns.</p> STDIOSSE (HttpClient)Streamable HTTPSSE (WebFlux) <p>Creates transport for process-based communication using stdin/stdout:</p> <pre><code>ServerParameters params = ServerParameters.builder(\"npx\")\n    .args(\"-y\", \"@modelcontextprotocol/server-everything\", \"dir\")\n    .build();\nMcpTransport transport = new StdioClientTransport(params);\n</code></pre> <p>Creates a framework-agnostic (pure Java API) SSE client transport. Included in the core <code>mcp</code> module:</p> <pre><code>McpTransport transport = new HttpClientSseClientTransport(\"http://your-mcp-server\");\n</code></pre> <p>Creates a Streamable HTTP client transport for efficient bidirectional communication. Included in the core <code>mcp</code> module:</p> <pre><code>McpTransport transport = HttpClientStreamableHttpTransport\n    .builder(\"http://your-mcp-server\")\n    .endpoint(\"/mcp\")\n    .build();\n</code></pre> <p>The Streamable HTTP transport supports:</p> <ul> <li>Resumable streams for connection recovery</li> <li>Configurable connect timeout</li> <li>Custom HTTP request customization</li> <li>Multiple protocol version negotiation</li> </ul> <p>Creates WebFlux-based SSE client transport. Requires the <code>mcp-spring-webflux</code> dependency:</p> <pre><code>WebClient.Builder webClientBuilder = WebClient.builder()\n    .baseUrl(\"http://your-mcp-server\");\nMcpTransport transport = new WebFluxSseClientTransport(webClientBuilder);\n</code></pre>"},{"location":"client/#client-capabilities","title":"Client Capabilities","text":"<p>The client can be configured with various capabilities:</p> <pre><code>var capabilities = ClientCapabilities.builder()\n    .roots(true)       // Enable filesystem roots support with list changes notifications\n    .sampling()        // Enable LLM sampling support\n    .elicitation()     // Enable elicitation support (form and URL modes)\n    .build();\n</code></pre> <p>You can also configure elicitation with specific mode support:</p> <pre><code>var capabilities = ClientCapabilities.builder()\n    .elicitation(true, false)  // Enable form-based elicitation, disable URL-based\n    .build();\n</code></pre>"},{"location":"client/#roots-support","title":"Roots Support","text":"<p>Roots define the boundaries of where servers can operate within the filesystem:</p> <pre><code>// Add a root dynamically\nclient.addRoot(new Root(\"file:///path\", \"description\"));\n\n// Remove a root\nclient.removeRoot(\"file:///path\");\n\n// Notify server of roots changes\nclient.rootsListChangedNotification();\n</code></pre> <p>The roots capability allows servers to:</p> <ul> <li>Request the list of accessible filesystem roots</li> <li>Receive notifications when the roots list changes</li> <li>Understand which directories and files they have access to</li> </ul>"},{"location":"client/#sampling-support","title":"Sampling Support","text":"<p>Sampling enables servers to request LLM interactions (\"completions\" or \"generations\") through the client:</p> <pre><code>// Configure sampling handler\nFunction&lt;CreateMessageRequest, CreateMessageResult&gt; samplingHandler = request -&gt; {\n    // Sampling implementation that interfaces with LLM\n    return new CreateMessageResult(response);\n};\n\n// Create client with sampling support\nvar client = McpClient.sync(transport)\n    .capabilities(ClientCapabilities.builder()\n        .sampling()\n        .build())\n    .sampling(samplingHandler)\n    .build();\n</code></pre> <p>This capability allows:</p> <ul> <li>Servers to leverage AI capabilities without requiring API keys</li> <li>Clients to maintain control over model access and permissions</li> <li>Support for both text and image-based interactions</li> <li>Optional inclusion of MCP server context in prompts</li> </ul>"},{"location":"client/#elicitation-support","title":"Elicitation Support","text":"<p>Elicitation enables servers to request additional information or user input through the client. This is useful when a server needs clarification or confirmation during an operation:</p> <pre><code>// Configure elicitation handler\nFunction&lt;ElicitRequest, ElicitResult&gt; elicitationHandler = request -&gt; {\n    // Present the request to the user and collect their response\n    // The request contains a message and a schema describing the expected input\n    Map&lt;String, Object&gt; userResponse = collectUserInput(request.message(), request.requestedSchema());\n    return new ElicitResult(ElicitResult.Action.ACCEPT, userResponse);\n};\n\n// Create client with elicitation support\nvar client = McpClient.sync(transport)\n    .capabilities(ClientCapabilities.builder()\n        .elicitation()\n        .build())\n    .elicitation(elicitationHandler)\n    .build();\n</code></pre> <p>The <code>ElicitResult</code> supports three actions:</p> <ul> <li><code>ACCEPT</code> - The user accepted and provided the requested information</li> <li><code>DECLINE</code> - The user declined to provide the information</li> <li><code>CANCEL</code> - The operation was cancelled</li> </ul>"},{"location":"client/#logging-support","title":"Logging Support","text":"<p>The client can register a logging consumer to receive log messages from the server and set the minimum logging level to filter messages:</p> <pre><code>var mcpClient = McpClient.sync(transport)\n        .loggingConsumer(notification -&gt; {\n            System.out.println(\"Received log message: \" + notification.data());\n        })\n        .build();\n\nmcpClient.initialize();\n\nmcpClient.setLoggingLevel(McpSchema.LoggingLevel.INFO);\n\n// Call the tool that sends logging notifications\nCallToolResult result = mcpClient.callTool(new CallToolRequest(\"logging-test\", Map.of()));\n</code></pre> <p>Clients can control the minimum logging level they receive through the <code>mcpClient.setLoggingLevel(level)</code> request. Messages below the set level will be filtered out. Supported logging levels (in order of increasing severity): DEBUG (0), INFO (1), NOTICE (2), WARNING (3), ERROR (4), CRITICAL (5), ALERT (6), EMERGENCY (7)</p>"},{"location":"client/#progress-notifications","title":"Progress Notifications","text":"<p>The client can register a progress consumer to track the progress of long-running operations:</p> <pre><code>var mcpClient = McpClient.sync(transport)\n    .progressConsumer(progress -&gt; {\n        System.out.println(\"Progress: \" + progress.progress() + \"/\" + progress.total());\n    })\n    .build();\n</code></pre>"},{"location":"client/#using-mcp-clients","title":"Using MCP Clients","text":""},{"location":"client/#tool-execution","title":"Tool Execution","text":"<p>Tools are server-side functions that clients can discover and execute. The MCP client provides methods to list available tools and execute them with specific parameters. Each tool has a unique name and accepts a map of parameters.</p> Sync APIAsync API <pre><code>// List available tools\nListToolsResult tools = client.listTools();\n\n// Call a tool with a CallToolRequest\nCallToolResult result = client.callTool(\n    new CallToolRequest(\"calculator\", Map.of(\n        \"operation\", \"add\",\n        \"a\", 1,\n        \"b\", 2\n    ))\n);\n</code></pre> <pre><code>// List available tools asynchronously\nclient.listTools()\n    .doOnNext(tools -&gt; tools.tools().forEach(tool -&gt;\n        System.out.println(tool.name())))\n    .subscribe();\n\n// Call a tool asynchronously\nclient.callTool(new CallToolRequest(\"calculator\", Map.of(\n        \"operation\", \"add\",\n        \"a\", 1,\n        \"b\", 2\n    )))\n    .subscribe();\n</code></pre>"},{"location":"client/#tool-schema-validation-and-caching","title":"Tool Schema Validation and Caching","text":"<p>The client supports optional JSON schema validation for tool call results and automatic schema caching:</p> <pre><code>var client = McpClient.sync(transport)\n    .jsonSchemaValidator(myValidator)            // Enable schema validation\n    .enableCallToolSchemaCaching(true)           // Cache tool schemas\n    .build();\n</code></pre>"},{"location":"client/#resource-access","title":"Resource Access","text":"<p>Resources represent server-side data sources that clients can access using URI templates. The MCP client provides methods to discover available resources and retrieve their contents through a standardized interface.</p> Sync APIAsync API <pre><code>// List available resources\nListResourcesResult resources = client.listResources();\n\n// Read a resource\nReadResourceResult resource = client.readResource(\n    new ReadResourceRequest(\"resource://uri\")\n);\n</code></pre> <pre><code>// List available resources asynchronously\nclient.listResources()\n    .doOnNext(resources -&gt; resources.resources().forEach(resource -&gt;\n        System.out.println(resource.name())))\n    .subscribe();\n\n// Read a resource asynchronously\nclient.readResource(new ReadResourceRequest(\"resource://uri\"))\n    .subscribe();\n</code></pre>"},{"location":"client/#prompt-system","title":"Prompt System","text":"<p>The prompt system enables interaction with server-side prompt templates. These templates can be discovered and executed with custom parameters, allowing for dynamic text generation based on predefined patterns.</p> Sync APIAsync API <pre><code>// List available prompt templates\nListPromptsResult prompts = client.listPrompts();\n\n// Get a prompt with parameters\nGetPromptResult prompt = client.getPrompt(\n    new GetPromptRequest(\"greeting\", Map.of(\"name\", \"World\"))\n);\n</code></pre> <pre><code>// List available prompt templates asynchronously\nclient.listPrompts()\n    .doOnNext(prompts -&gt; prompts.prompts().forEach(prompt -&gt;\n        System.out.println(prompt.name())))\n    .subscribe();\n\n// Get a prompt asynchronously\nclient.getPrompt(new GetPromptRequest(\"greeting\", Map.of(\"name\", \"World\")))\n    .subscribe();\n</code></pre>"},{"location":"contribute/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the Model Context Protocol Java SDK! This guide outlines how to contribute to this project.</p>"},{"location":"contribute/#prerequisites","title":"Prerequisites","text":"<p>Required Software</p> <ul> <li>Java 17 or above</li> <li>Docker</li> <li>npx</li> </ul>"},{"location":"contribute/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> <li> <p>Clone your fork:</p> <pre><code>git clone https://github.com/YOUR-USERNAME/java-sdk.git\ncd java-sdk\n</code></pre> </li> <li> <p>Build from source:</p> <pre><code>./mvnw clean install -DskipTests  # skip the tests\n./mvnw test                        # run tests\n</code></pre> </li> </ol>"},{"location":"contribute/#reporting-issues","title":"Reporting Issues","text":"<p>Please create an issue in the repository if you discover a bug or would like to propose an enhancement. Bug reports should have a reproducer in the form of a code sample or a repository attached that the maintainers or contributors can work with to address the problem.</p>"},{"location":"contribute/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Create a new branch:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> </li> <li> <p>Make your changes.</p> </li> <li> <p>Validate your changes:</p> <pre><code>./mvnw clean test\n</code></pre> </li> </ol>"},{"location":"contribute/#change-proposal-guidelines","title":"Change Proposal Guidelines","text":""},{"location":"contribute/#principles-of-mcp","title":"Principles of MCP","text":"<ol> <li>Simple + Minimal: It is much easier to add things to the codebase than it is to    remove them. To maintain simplicity, we keep a high bar for adding new concepts and    primitives as each addition requires maintenance and compatibility consideration.</li> <li>Concrete: Code changes need to be based on specific usage and implementation    challenges and not on speculative ideas. Most importantly, the SDK is meant to    implement the MCP specification.</li> </ol>"},{"location":"contribute/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>For non-trivial changes, please clarify with the maintainers in an issue whether    you can contribute the change and the desired scope of the change.</li> <li>For trivial changes (for example a couple of lines or documentation changes) there    is no need to open an issue first.</li> <li>Push your changes to your fork.</li> <li>Submit a pull request to the main repository.</li> <li>Follow the pull request template.</li> <li>Wait for review.</li> <li>For any follow-up work, please add new commits instead of force-pushing. This will    allow the reviewer to focus on incremental changes instead of having to restart the    review process.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>This project follows a Code of Conduct. Please review it in CODE_OF_CONDUCT.md.</p>"},{"location":"contribute/#questions","title":"Questions","text":"<p>If you have questions, please create a discussion in the repository.</p>"},{"location":"contribute/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"contribute/#security","title":"Security","text":"<p>This SDK is maintained by Anthropic as part of the Model Context Protocol project.</p> <p>The security of our systems and user data is Anthropic's top priority. We appreciate the work of security researchers acting in good faith in identifying and reporting potential vulnerabilities.</p> <p>Reporting Security Vulnerabilities</p> <p>Do not report security vulnerabilities through public GitHub issues. Instead, report them through our HackerOne submission form.</p> <p>Our Vulnerability Disclosure Program guidelines are defined on our HackerOne program page.</p>"},{"location":"development/","title":"Documentation Development","text":"<p>This guide covers how to set up and preview the MCP Java SDK documentation locally.</p> <p>Prerequisites</p> <ul> <li>Python 3.x</li> <li>pip (Python package manager)</li> </ul>"},{"location":"development/#setup","title":"Setup","text":"<p>Install mkdocs-material:</p> <pre><code>pip install mkdocs-material\n</code></pre>"},{"location":"development/#preview-locally","title":"Preview Locally","text":"<p>From the project root directory, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>A local preview of the documentation will be available at <code>http://localhost:8000</code>.</p>"},{"location":"development/#custom-ports","title":"Custom Ports","text":"<p>By default, mkdocs uses port 8000. You can customize the port with the <code>-a</code> flag:</p> <pre><code>mkdocs serve -a localhost:3333\n</code></pre>"},{"location":"development/#building","title":"Building","text":"<p>To build the static site for deployment:</p> <pre><code>mkdocs build\n</code></pre> <p>The built site will be output to the <code>site/</code> directory.</p>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md            # Overview page\n\u251c\u2500\u2500 quickstart.md       # Quickstart guide\n\u251c\u2500\u2500 client.md           # MCP Client documentation\n\u251c\u2500\u2500 server.md           # MCP Server documentation\n\u251c\u2500\u2500 contributing.md     # Contributing guide\n\u251c\u2500\u2500 development.md      # This page\n\u251c\u2500\u2500 images/             # Images and diagrams\n\u2514\u2500\u2500 stylesheets/        # Custom CSS\nmkdocs.yml              # MkDocs configuration\n</code></pre>"},{"location":"development/#writing-guidelines","title":"Writing Guidelines","text":"<ul> <li>Documentation pages use standard Markdown with mkdocs-material extensions</li> <li>Use content tabs (<code>=== \"Tab Label\"</code>) for Maven/Gradle or Sync/Async code examples</li> <li>Use admonitions (<code>!!! tip</code>, <code>!!! info</code>, <code>!!! warning</code>) for callouts</li> <li>All code blocks should specify a language for syntax highlighting</li> <li>Images go in the <code>docs/images/</code> directory</li> </ul>"},{"location":"development/#ide-support","title":"IDE Support","text":"<p>We suggest using extensions on your IDE to recognize and format Markdown. If you're a VSCode user, consider the Markdown All in One extension for enhanced Markdown support, and Prettier for code formatting.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#dependencies","title":"Dependencies","text":"<p>Add the following dependency to your project:</p> MavenGradle <p>The convenience <code>mcp</code> module bundles <code>mcp-core</code> with Jackson 3.x JSON serialization:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This includes default STDIO, SSE, and Streamable HTTP transport implementations without requiring external web frameworks.</p> <p>If you need only the core module without a JSON implementation (e.g., to bring your own):</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>For Jackson 2.x instead of Jackson 3.x:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp-core&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp-json-jackson2&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you're using the Spring Framework and want Spring-specific transport implementations, add one of the following optional dependencies:</p> <pre><code>&lt;!-- Optional: Spring WebFlux-based SSE and Streamable HTTP client and server transport --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp-spring-webflux&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;!-- Optional: Spring WebMVC-based SSE and Streamable HTTP server transport --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n    &lt;artifactId&gt;mcp-spring-webmvc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The convenience <code>mcp</code> module bundles <code>mcp-core</code> with Jackson 3.x JSON serialization:</p> <pre><code>dependencies {\n    implementation \"io.modelcontextprotocol.sdk:mcp\"\n}\n</code></pre> <p>This includes default STDIO, SSE, and Streamable HTTP transport implementations without requiring external web frameworks.</p> <p>If you need only the core module without a JSON implementation (e.g., to bring your own):</p> <pre><code>dependencies {\n    implementation \"io.modelcontextprotocol.sdk:mcp-core\"\n}\n</code></pre> <p>For Jackson 2.x instead of Jackson 3.x:</p> <pre><code>dependencies {\n    implementation \"io.modelcontextprotocol.sdk:mcp-core\"\n    implementation \"io.modelcontextprotocol.sdk:mcp-json-jackson2\"\n}\n</code></pre> <p>If you're using the Spring Framework and want Spring-specific transport implementations, add one of the following optional dependencies:</p> <pre><code>// Optional: Spring WebFlux-based SSE and Streamable HTTP client and server transport\ndependencies {\n    implementation \"io.modelcontextprotocol.sdk:mcp-spring-webflux\"\n}\n\n// Optional: Spring WebMVC-based SSE and Streamable HTTP server transport\ndependencies {\n    implementation \"io.modelcontextprotocol.sdk:mcp-spring-webmvc\"\n}\n</code></pre>"},{"location":"quickstart/#bill-of-materials-bom","title":"Bill of Materials (BOM)","text":"<p>The Bill of Materials (BOM) declares the recommended versions of all the dependencies used by a given release. Using the BOM from your application's build script avoids the need for you to specify and maintain the dependency versions yourself. Instead, the version of the BOM you're using determines the utilized dependency versions. It also ensures that you're using supported and tested versions of the dependencies by default, unless you choose to override them.</p> <p>Add the BOM to your project:</p> MavenGradle <pre><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.modelcontextprotocol.sdk&lt;/groupId&gt;\n            &lt;artifactId&gt;mcp-bom&lt;/artifactId&gt;\n            &lt;version&gt;1.0.0-RC1&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n</code></pre> <pre><code>dependencies {\n    implementation platform(\"io.modelcontextprotocol.sdk:mcp-bom:latest\")\n    //...\n}\n</code></pre> <p>Gradle users can also leverage Gradle (5.0+) native support for declaring dependency constraints using a Maven BOM. This is implemented by adding a 'platform' dependency handler method to the dependencies section of your Gradle build script. As shown in the snippet above this can then be followed by version-less declarations of the dependencies.</p> <p>Replace the version number with the latest version from Maven Central.</p>"},{"location":"quickstart/#available-dependencies","title":"Available Dependencies","text":"<p>The following dependencies are available and managed by the BOM:</p> <ul> <li>Core Dependencies<ul> <li><code>io.modelcontextprotocol.sdk:mcp-core</code> - Core MCP library providing the base functionality, APIs, and default transport implementations (STDIO, SSE, Streamable HTTP). JSON binding is abstracted for pluggability.</li> <li><code>io.modelcontextprotocol.sdk:mcp</code> - Convenience bundle that combines <code>mcp-core</code> with <code>mcp-json-jackson3</code> for out-of-the-box usage.</li> </ul> </li> <li>JSON Serialization<ul> <li><code>io.modelcontextprotocol.sdk:mcp-json-jackson3</code> - Jackson 3.x JSON serialization implementation (included in <code>mcp</code> bundle).</li> <li><code>io.modelcontextprotocol.sdk:mcp-json-jackson2</code> - Jackson 2.x JSON serialization implementation for projects that require Jackson 2.x compatibility.</li> </ul> </li> <li>Optional Transport Dependencies (convenience if using Spring Framework)<ul> <li><code>io.modelcontextprotocol.sdk:mcp-spring-webflux</code> - WebFlux-based SSE and Streamable HTTP transport implementation for reactive applications.</li> <li><code>io.modelcontextprotocol.sdk:mcp-spring-webmvc</code> - WebMVC-based SSE and Streamable HTTP transport implementation for servlet-based applications.</li> </ul> </li> <li>Testing Dependencies<ul> <li><code>io.modelcontextprotocol.sdk:mcp-test</code> - Testing utilities and support for MCP-based applications.</li> </ul> </li> </ul>"},{"location":"server/","title":"MCP Server","text":""},{"location":"server/#overview","title":"Overview","text":"<p>The MCP Server is a foundational component in the Model Context Protocol (MCP) architecture that provides tools, resources, and capabilities to clients. It implements the server-side of the protocol, responsible for:</p> <ul> <li>Exposing tools that clients can discover and execute</li> <li>Managing resources with URI-based access patterns and resource templates</li> <li>Providing prompt templates and handling prompt requests</li> <li>Supporting capability negotiation with clients</li> <li>Providing argument autocompletion suggestions (completions)</li> <li>Implementing server-side protocol operations</li> <li>Managing concurrent client connections</li> <li>Providing structured logging and notifications</li> </ul> <p>Tip</p> <p>The core <code>io.modelcontextprotocol.sdk:mcp</code> module provides STDIO, SSE, and Streamable HTTP server transport implementations without requiring external web frameworks.</p> <p>Spring-specific transport implementations are available as optional dependencies <code>io.modelcontextprotocol.sdk:mcp-spring-webflux</code>, <code>io.modelcontextprotocol.sdk:mcp-spring-webmvc</code> for Spring Framework users.</p> <p>The server supports both synchronous and asynchronous APIs, allowing for flexible integration in different application contexts.</p> Sync APIAsync API <pre><code>// Create a server with custom configuration\nMcpSyncServer syncServer = McpServer.sync(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(false, true)  // Enable resource support with list changes\n        .tools(true)             // Enable tool support with list changes\n        .prompts(true)           // Enable prompt support with list changes\n        .completions()           // Enable completions support\n        .logging()               // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nsyncServer.addTool(syncToolSpecification);\nsyncServer.addResource(syncResourceSpecification);\nsyncServer.addPrompt(syncPromptSpecification);\n\n// Close the server when done\nsyncServer.close();\n</code></pre> <pre><code>// Create an async server with custom configuration\nMcpAsyncServer asyncServer = McpServer.async(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .capabilities(ServerCapabilities.builder()\n        .resources(false, true)  // Enable resource support with list changes\n        .tools(true)             // Enable tool support with list changes\n        .prompts(true)           // Enable prompt support with list changes\n        .completions()           // Enable completions support\n        .logging()               // Enable logging support\n        .build())\n    .build();\n\n// Register tools, resources, and prompts\nasyncServer.addTool(asyncToolSpecification)\n    .doOnSuccess(v -&gt; logger.info(\"Tool registered\"))\n    .subscribe();\n\nasyncServer.addResource(asyncResourceSpecification)\n    .doOnSuccess(v -&gt; logger.info(\"Resource registered\"))\n    .subscribe();\n\nasyncServer.addPrompt(asyncPromptSpecification)\n    .doOnSuccess(v -&gt; logger.info(\"Prompt registered\"))\n    .subscribe();\n\n// Close the server when done\nasyncServer.close()\n    .doOnSuccess(v -&gt; logger.info(\"Server closed\"))\n    .subscribe();\n</code></pre>"},{"location":"server/#server-types","title":"Server Types","text":"<p>The SDK supports multiple server creation patterns depending on your transport requirements:</p> <pre><code>// Single-session server with SSE transport provider\nMcpSyncServer server = McpServer.sync(sseTransportProvider).build();\n\n// Streamable HTTP server\nMcpSyncServer server = McpServer.sync(streamableTransportProvider).build();\n\n// Stateless server (no session management)\nMcpSyncServer server = McpServer.sync(statelessTransport).build();\n</code></pre>"},{"location":"server/#server-transport-providers","title":"Server Transport Providers","text":"<p>The transport layer in the MCP SDK is responsible for handling the communication between clients and servers. It provides different implementations to support various communication protocols and patterns. The SDK includes several built-in transport provider implementations:</p> STDIOStreamable HTTP (Servlet)Streamable HTTP (WebFlux)Streamable HTTP (WebMvc)SSE (WebFlux)SSE (WebMvc)SSE (Servlet) <p>Create process-based transport using stdin/stdout:</p> <pre><code>StdioServerTransportProvider transportProvider =\n    new StdioServerTransportProvider(new ObjectMapper());\n</code></pre> <p>Provides bidirectional JSON-RPC message handling over standard input/output streams with non-blocking message processing, serialization/deserialization, and graceful shutdown support.</p> <p>Key features:</p> <ul> <li>Bidirectional communication through stdin/stdout</li> <li>Process-based integration support</li> <li>Simple setup and configuration</li> <li>Lightweight implementation</li> </ul> <p>Creates a Servlet-based Streamable HTTP server transport. Included in the core <code>mcp</code> module:</p> <pre><code>HttpServletStreamableServerTransportProvider transportProvider =\n    HttpServletStreamableServerTransportProvider.builder()\n        .jsonMapper(jsonMapper)\n        .mcpEndpoint(\"/mcp\")\n        .build();\n</code></pre> <p>To use with a Spring Web application, register it as a Servlet bean:</p> <pre><code>@Configuration\n@EnableWebMvc\npublic class McpServerConfig implements WebMvcConfigurer {\n\n    @Bean\n    public HttpServletStreamableServerTransportProvider transportProvider(McpJsonMapper jsonMapper) {\n        return HttpServletStreamableServerTransportProvider.builder()\n            .jsonMapper(jsonMapper)\n            .mcpEndpoint(\"/mcp\")\n            .build();\n    }\n\n    @Bean\n    public ServletRegistrationBean&lt;?&gt; mcpServlet(\n            HttpServletStreamableServerTransportProvider transportProvider) {\n        return new ServletRegistrationBean&lt;&gt;(transportProvider);\n    }\n}\n</code></pre> <p>Key features:</p> <ul> <li>Efficient bidirectional HTTP communication</li> <li>Session management for multiple client connections</li> <li>Configurable keep-alive intervals</li> <li>Security validation support</li> <li>Graceful shutdown support</li> </ul> <p>Creates WebFlux-based Streamable HTTP server transport. Requires the <code>mcp-spring-webflux</code> dependency:</p> <pre><code>@Configuration\nclass McpConfig {\n    @Bean\n    WebFluxStreamableServerTransportProvider transportProvider(McpJsonMapper jsonMapper) {\n        return WebFluxStreamableServerTransportProvider.builder()\n            .jsonMapper(jsonMapper)\n            .messageEndpoint(\"/mcp\")\n            .build();\n    }\n\n    @Bean\n    RouterFunction&lt;?&gt; mcpRouterFunction(\n            WebFluxStreamableServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n</code></pre> <p>Key features:</p> <ul> <li>Reactive HTTP streaming with WebFlux</li> <li>Concurrent client connections</li> <li>Configurable keep-alive intervals</li> <li>Security validation support</li> </ul> <p>Creates WebMvc-based Streamable HTTP server transport. Requires the <code>mcp-spring-webmvc</code> dependency:</p> <pre><code>@Configuration\n@EnableWebMvc\nclass McpConfig {\n    @Bean\n    WebMvcStreamableServerTransportProvider transportProvider(McpJsonMapper jsonMapper) {\n        return WebMvcStreamableServerTransportProvider.builder()\n            .jsonMapper(jsonMapper)\n            .mcpEndpoint(\"/mcp\")\n            .build();\n    }\n\n    @Bean\n    RouterFunction&lt;ServerResponse&gt; mcpRouterFunction(\n            WebMvcStreamableServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n</code></pre> <p>Creates WebFlux-based SSE server transport. Requires the <code>mcp-spring-webflux</code> dependency:</p> <pre><code>@Configuration\nclass McpConfig {\n    @Bean\n    WebFluxSseServerTransportProvider webFluxSseServerTransportProvider(ObjectMapper mapper) {\n        return new WebFluxSseServerTransportProvider(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction&lt;?&gt; mcpRouterFunction(WebFluxSseServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n</code></pre> <p>Implements the MCP HTTP with SSE transport specification, providing:</p> <ul> <li>Reactive HTTP streaming with WebFlux</li> <li>Concurrent client connections through SSE endpoints</li> <li>Message routing and session management</li> <li>Graceful shutdown capabilities</li> </ul> <p>Creates WebMvc-based SSE server transport. Requires the <code>mcp-spring-webmvc</code> dependency:</p> <pre><code>@Configuration\n@EnableWebMvc\nclass McpConfig {\n    @Bean\n    WebMvcSseServerTransportProvider webMvcSseServerTransportProvider(ObjectMapper mapper) {\n        return new WebMvcSseServerTransportProvider(mapper, \"/mcp/message\");\n    }\n\n    @Bean\n    RouterFunction&lt;ServerResponse&gt; mcpRouterFunction(\n            WebMvcSseServerTransportProvider transportProvider) {\n        return transportProvider.getRouterFunction();\n    }\n}\n</code></pre> <p>Implements the MCP HTTP with SSE transport specification, providing:</p> <ul> <li>Server-side event streaming</li> <li>Integration with Spring WebMVC</li> <li>Support for traditional web applications</li> <li>Synchronous operation handling</li> </ul> <p>Creates a Servlet-based SSE server transport. Included in the core <code>mcp</code> module. The <code>HttpServletSseServerTransportProvider</code> can be used with any Servlet container. To use it with a Spring Web application, you can register it as a Servlet bean:</p> <pre><code>@Configuration\n@EnableWebMvc\npublic class McpServerConfig implements WebMvcConfigurer {\n\n    @Bean\n    public HttpServletSseServerTransportProvider servletSseServerTransportProvider() {\n        return new HttpServletSseServerTransportProvider(new ObjectMapper(), \"/mcp/message\");\n    }\n\n    @Bean\n    public ServletRegistrationBean&lt;?&gt; customServletBean(\n            HttpServletSseServerTransportProvider transportProvider) {\n        return new ServletRegistrationBean&lt;&gt;(transportProvider);\n    }\n}\n</code></pre> <p>Implements the MCP HTTP with SSE transport specification using the traditional Servlet API, providing:</p> <ul> <li>Asynchronous message handling using Servlet 6.0 async support</li> <li>Session management for multiple client connections</li> <li>Two types of endpoints:<ul> <li>SSE endpoint (<code>/sse</code>) for server-to-client events</li> <li>Message endpoint (configurable) for client-to-server requests</li> </ul> </li> <li>Error handling and response formatting</li> <li>Graceful shutdown support</li> </ul>"},{"location":"server/#server-capabilities","title":"Server Capabilities","text":"<p>The server can be configured with various capabilities:</p> <pre><code>var capabilities = ServerCapabilities.builder()\n    .resources(false, true)  // Resource support (subscribe, listChanged)\n    .tools(true)             // Tool support with list changes notifications\n    .prompts(true)           // Prompt support with list changes notifications\n    .completions()           // Enable completions support\n    .logging()               // Enable logging support\n    .build();\n</code></pre>"},{"location":"server/#tool-specification","title":"Tool Specification","text":"<p>The Model Context Protocol allows servers to expose tools that can be invoked by language models. The Java SDK allows implementing Tool Specifications with their handler functions. Tools enable AI models to perform calculations, access external APIs, query databases, and manipulate files.</p> <p>The recommended approach is to use the builder pattern and <code>CallToolRequest</code> as the handler parameter:</p> SyncAsync <pre><code>// Sync tool specification using builder\nvar syncToolSpecification = SyncToolSpecification.builder()\n    .tool(Tool.builder()\n        .name(\"calculator\")\n        .description(\"Basic calculator\")\n        .inputSchema(schema)\n        .build())\n    .callHandler((exchange, request) -&gt; {\n        // Access arguments via request.arguments()\n        String operation = (String) request.arguments().get(\"operation\");\n        int a = (int) request.arguments().get(\"a\");\n        int b = (int) request.arguments().get(\"b\");\n        // Tool implementation\n        return CallToolResult.builder()\n            .content(List.of(new McpSchema.TextContent(\"Result: \" + result)))\n            .build();\n    })\n    .build();\n</code></pre> <pre><code>// Async tool specification using builder\nvar asyncToolSpecification = AsyncToolSpecification.builder()\n    .tool(Tool.builder()\n        .name(\"calculator\")\n        .description(\"Basic calculator\")\n        .inputSchema(schema)\n        .build())\n    .callHandler((exchange, request) -&gt; {\n        // Access arguments via request.arguments()\n        String operation = (String) request.arguments().get(\"operation\");\n        int a = (int) request.arguments().get(\"a\");\n        int b = (int) request.arguments().get(\"b\");\n        // Tool implementation\n        return Mono.just(CallToolResult.builder()\n            .content(List.of(new McpSchema.TextContent(\"Result: \" + result)))\n            .build());\n    })\n    .build();\n</code></pre> <p>The Tool specification includes a Tool definition with <code>name</code>, <code>description</code>, and <code>inputSchema</code> followed by a call handler that implements the tool's logic. The handler receives <code>McpSyncServerExchange</code>/<code>McpAsyncServerExchange</code> for client interaction and a <code>CallToolRequest</code> containing the tool arguments.</p> <p>You can also register tools directly on the server builder using the <code>toolCall</code> convenience method:</p> <pre><code>var server = McpServer.sync(transportProvider)\n    .toolCall(\n        Tool.builder().name(\"echo\").description(\"Echoes input\").inputSchema(schema).build(),\n        (exchange, request) -&gt; CallToolResult.builder()\n            .content(List.of(new McpSchema.TextContent(request.arguments().get(\"text\").toString())))\n            .build()\n    )\n    .build();\n</code></pre>"},{"location":"server/#resource-specification","title":"Resource Specification","text":"<p>Specification of a resource with its handler function. Resources provide context to AI models by exposing data such as: File contents, Database records, API responses, System information, Application state.</p> SyncAsync <pre><code>// Sync resource specification\nvar syncResourceSpecification = new McpServerFeatures.SyncResourceSpecification(\n    Resource.builder()\n        .uri(\"custom://resource\")\n        .name(\"name\")\n        .description(\"description\")\n        .mimeType(\"text/plain\")\n        .build(),\n    (exchange, request) -&gt; {\n        // Resource read implementation\n        return new ReadResourceResult(contents);\n    }\n);\n</code></pre> <pre><code>// Async resource specification\nvar asyncResourceSpecification = new McpServerFeatures.AsyncResourceSpecification(\n    Resource.builder()\n        .uri(\"custom://resource\")\n        .name(\"name\")\n        .description(\"description\")\n        .mimeType(\"text/plain\")\n        .build(),\n    (exchange, request) -&gt; {\n        // Resource read implementation\n        return Mono.just(new ReadResourceResult(contents));\n    }\n);\n</code></pre>"},{"location":"server/#resource-template-specification","title":"Resource Template Specification","text":"<p>Resource templates allow servers to expose parameterized resources using URI templates:</p> <pre><code>// Resource template specification\nvar resourceTemplateSpec = new McpServerFeatures.SyncResourceTemplateSpecification(\n    ResourceTemplate.builder()\n        .uriTemplate(\"file://{path}\")\n        .name(\"File Resource\")\n        .description(\"Access files by path\")\n        .mimeType(\"application/octet-stream\")\n        .build(),\n    (exchange, request) -&gt; {\n        // Read the file at the requested URI\n        return new ReadResourceResult(contents);\n    }\n);\n</code></pre>"},{"location":"server/#prompt-specification","title":"Prompt Specification","text":"<p>As part of the Prompting capabilities, MCP provides a standardized way for servers to expose prompt templates to clients. The Prompt Specification is a structured template for AI model interactions that enables consistent message formatting, parameter substitution, context injection, response formatting, and instruction templating.</p> SyncAsync <pre><code>// Sync prompt specification\nvar syncPromptSpecification = new McpServerFeatures.SyncPromptSpecification(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    (exchange, request) -&gt; {\n        // Prompt implementation\n        return new GetPromptResult(description, messages);\n    }\n);\n</code></pre> <pre><code>// Async prompt specification\nvar asyncPromptSpecification = new McpServerFeatures.AsyncPromptSpecification(\n    new Prompt(\"greeting\", \"description\", List.of(\n        new PromptArgument(\"name\", \"description\", true)\n    )),\n    (exchange, request) -&gt; {\n        // Prompt implementation\n        return Mono.just(new GetPromptResult(description, messages));\n    }\n);\n</code></pre> <p>The prompt definition includes name (identifier for the prompt), description (purpose of the prompt), and list of arguments (parameters for templating). The handler function processes requests and returns formatted templates. The first argument is <code>McpSyncServerExchange</code>/<code>McpAsyncServerExchange</code> for client interaction, and the second argument is a <code>GetPromptRequest</code> instance.</p>"},{"location":"server/#completion-specification","title":"Completion Specification","text":"<p>Completions allow servers to provide argument autocompletion suggestions for prompts and resources:</p> SyncAsync <pre><code>// Sync completion specification\nvar syncCompletionSpec = new McpServerFeatures.SyncCompletionSpecification(\n    new McpSchema.PromptReference(\"greeting\"),  // Reference to a prompt\n    (exchange, request) -&gt; {\n        String argName = request.argument().name();\n        String partial = request.argument().value();\n        // Return matching suggestions\n        List&lt;String&gt; suggestions = findMatches(partial);\n        return new McpSchema.CompleteResult(\n            new McpSchema.CompleteResult.CompleteCompletion(suggestions, suggestions.size(), false)\n        );\n    }\n);\n</code></pre> <pre><code>// Async completion specification\nvar asyncCompletionSpec = new McpServerFeatures.AsyncCompletionSpecification(\n    new McpSchema.PromptReference(\"greeting\"),\n    (exchange, request) -&gt; {\n        String argName = request.argument().name();\n        String partial = request.argument().value();\n        List&lt;String&gt; suggestions = findMatches(partial);\n        return Mono.just(new McpSchema.CompleteResult(\n            new McpSchema.CompleteResult.CompleteCompletion(suggestions, suggestions.size(), false)\n        ));\n    }\n);\n</code></pre> <p>Completions can be registered for both <code>PromptReference</code> and <code>ResourceReference</code> types.</p>"},{"location":"server/#using-sampling-from-a-server","title":"Using Sampling from a Server","text":"<p>To use Sampling capabilities, connect to a client that supports sampling. No special server configuration is needed, but verify client sampling support before making requests. Learn about client sampling support.</p> <p>Once connected to a compatible client, the server can request language model generations:</p> Sync APIAsync API <pre><code>// Create a server\nMcpSyncServer server = McpServer.sync(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .build();\n\n// Define a tool that uses sampling\nvar calculatorTool = SyncToolSpecification.builder()\n    .tool(Tool.builder()\n        .name(\"ai-calculator\")\n        .description(\"Performs calculations using AI\")\n        .inputSchema(schema)\n        .build())\n    .callHandler((exchange, request) -&gt; {\n        // Check if client supports sampling\n        if (exchange.getClientCapabilities().sampling() == null) {\n            return CallToolResult.builder()\n                .content(List.of(new McpSchema.TextContent(\"Client does not support AI capabilities\")))\n                .build();\n        }\n\n        // Create a sampling request\n        CreateMessageRequest samplingRequest = CreateMessageRequest.builder()\n            .messages(List.of(new McpSchema.SamplingMessage(McpSchema.Role.USER,\n                new McpSchema.TextContent(\"Calculate: \" + request.arguments().get(\"expression\")))))\n            .modelPreferences(McpSchema.ModelPreferences.builder()\n                .hints(List.of(\n                    McpSchema.ModelHint.of(\"claude-3-sonnet\"),\n                    McpSchema.ModelHint.of(\"claude\")\n                ))\n                .intelligencePriority(0.8)\n                .speedPriority(0.5)\n                .build())\n            .systemPrompt(\"You are a helpful calculator assistant. Provide only the numerical answer.\")\n            .maxTokens(100)\n            .build();\n\n        // Request sampling from the client\n        CreateMessageResult result = exchange.createMessage(samplingRequest);\n\n        // Process the result\n        String answer = ((McpSchema.TextContent) result.content()).text();\n        return CallToolResult.builder()\n            .content(List.of(new McpSchema.TextContent(answer)))\n            .build();\n    })\n    .build();\n\n// Add the tool to the server\nserver.addTool(calculatorTool);\n</code></pre> <pre><code>// Create a server\nMcpAsyncServer server = McpServer.async(transportProvider)\n    .serverInfo(\"my-server\", \"1.0.0\")\n    .build();\n\n// Define a tool that uses sampling\nvar calculatorTool = AsyncToolSpecification.builder()\n    .tool(Tool.builder()\n        .name(\"ai-calculator\")\n        .description(\"Performs calculations using AI\")\n        .inputSchema(schema)\n        .build())\n    .callHandler((exchange, request) -&gt; {\n        // Check if client supports sampling\n        if (exchange.getClientCapabilities().sampling() == null) {\n            return Mono.just(CallToolResult.builder()\n                .content(List.of(new McpSchema.TextContent(\"Client does not support AI capabilities\")))\n                .build());\n        }\n\n        // Create a sampling request\n        CreateMessageRequest samplingRequest = CreateMessageRequest.builder()\n            .messages(List.of(new McpSchema.SamplingMessage(McpSchema.Role.USER,\n                new McpSchema.TextContent(\"Calculate: \" + request.arguments().get(\"expression\")))))\n            .modelPreferences(McpSchema.ModelPreferences.builder()\n                .hints(List.of(\n                    McpSchema.ModelHint.of(\"claude-3-sonnet\"),\n                    McpSchema.ModelHint.of(\"claude\")\n                ))\n                .intelligencePriority(0.8)\n                .speedPriority(0.5)\n                .build())\n            .systemPrompt(\"You are a helpful calculator assistant. Provide only the numerical answer.\")\n            .maxTokens(100)\n            .build();\n\n        // Request sampling from the client\n        return exchange.createMessage(samplingRequest)\n            .map(result -&gt; {\n                String answer = ((McpSchema.TextContent) result.content()).text();\n                return CallToolResult.builder()\n                    .content(List.of(new McpSchema.TextContent(answer)))\n                    .build();\n            });\n    })\n    .build();\n\n// Add the tool to the server\nserver.addTool(calculatorTool)\n    .subscribe();\n</code></pre> <p>The <code>CreateMessageRequest</code> object allows you to specify: <code>Content</code> - the input text or image for the model, <code>Model Preferences</code> - hints and priorities for model selection, <code>System Prompt</code> - instructions for the model's behavior and <code>Max Tokens</code> - maximum length of the generated response.</p>"},{"location":"server/#using-elicitation-from-a-server","title":"Using Elicitation from a Server","text":"<p>Servers can request user input from connected clients that support elicitation:</p> <pre><code>var tool = SyncToolSpecification.builder()\n    .tool(Tool.builder()\n        .name(\"confirm-action\")\n        .description(\"Confirms an action with the user\")\n        .inputSchema(schema)\n        .build())\n    .callHandler((exchange, request) -&gt; {\n        // Check if client supports elicitation\n        if (exchange.getClientCapabilities().elicitation() == null) {\n            return CallToolResult.builder()\n                .content(List.of(new McpSchema.TextContent(\"Client does not support elicitation\")))\n                .build();\n        }\n\n        // Request user confirmation\n        ElicitRequest elicitRequest = ElicitRequest.builder()\n            .message(\"Do you want to proceed with this action?\")\n            .requestedSchema(Map.of(\n                \"type\", \"object\",\n                \"properties\", Map.of(\"confirmed\", Map.of(\"type\", \"boolean\"))\n            ))\n            .build();\n\n        ElicitResult result = exchange.elicit(elicitRequest);\n\n        if (result.action() == ElicitResult.Action.ACCEPT) {\n            // User accepted\n            return CallToolResult.builder()\n                .content(List.of(new McpSchema.TextContent(\"Action confirmed\")))\n                .build();\n        } else {\n            return CallToolResult.builder()\n                .content(List.of(new McpSchema.TextContent(\"Action declined\")))\n                .build();\n        }\n    })\n    .build();\n</code></pre>"},{"location":"server/#logging-support","title":"Logging Support","text":"<p>The server provides structured logging capabilities that allow sending log messages to clients with different severity levels. Log notifications can only be sent from within an existing client session, such as tools, resources, and prompts calls.</p> <p>The server can send log messages using the <code>McpAsyncServerExchange</code>/<code>McpSyncServerExchange</code> object in the tool/resource/prompt handler function:</p> <pre><code>var tool = new McpServerFeatures.AsyncToolSpecification(\n    Tool.builder().name(\"logging-test\").description(\"Test logging notifications\").inputSchema(emptyJsonSchema).build(),\n    null,\n    (exchange, request) -&gt; {\n\n      exchange.loggingNotification( // Use the exchange to send log messages\n          McpSchema.LoggingMessageNotification.builder()\n            .level(McpSchema.LoggingLevel.DEBUG)\n            .logger(\"test-logger\")\n            .data(\"Debug message\")\n            .build())\n        .block();\n\n      return Mono.just(CallToolResult.builder()\n          .content(List.of(new McpSchema.TextContent(\"Logging test completed\")))\n          .build());\n    });\n\nvar mcpServer = McpServer.async(mcpServerTransportProvider)\n  .serverInfo(\"test-server\", \"1.0.0\")\n  .capabilities(\n    ServerCapabilities.builder()\n      .logging() // Enable logging support\n      .tools(true)\n      .build())\n  .tools(tool)\n  .build();\n</code></pre> <p>On the client side, you can register a logging consumer to receive log messages from the server:</p> <pre><code>var mcpClient = McpClient.sync(transport)\n        .loggingConsumer(notification -&gt; {\n            System.out.println(\"Received log message: \" + notification.data());\n        })\n        .build();\n\nmcpClient.initialize();\nmcpClient.setLoggingLevel(McpSchema.LoggingLevel.INFO);\n</code></pre> <p>Clients can control the minimum logging level they receive through the <code>mcpClient.setLoggingLevel(level)</code> request. Messages below the set level will be filtered out. Supported logging levels (in order of increasing severity): DEBUG (0), INFO (1), NOTICE (2), WARNING (3), ERROR (4), CRITICAL (5), ALERT (6), EMERGENCY (7)</p>"},{"location":"server/#error-handling","title":"Error Handling","text":"<p>The SDK provides comprehensive error handling through the McpError class, covering protocol compatibility, transport communication, JSON-RPC messaging, tool execution, resource management, prompt handling, timeouts, and connection issues. This unified error handling approach ensures consistent and reliable error management across both synchronous and asynchronous operations.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2026/02/15/java-leads-mcp-server-performance-benchmarks-with-sub-millisecond-latency/","title":"Java Leads MCP Server Performance Benchmarks with Sub-Millisecond Latency","text":"<p>A comprehensive independent benchmark of MCP server implementations across four major languages puts Java at the top of the performance charts \u2014 delivering sub-millisecond latency, the highest throughput, and the best CPU efficiency of all tested platforms.</p>"},{"location":"blog/2026/02/15/java-leads-mcp-server-performance-benchmarks-with-sub-millisecond-latency/#the-benchmark","title":"The Benchmark","text":"<p>TM Dev Lab published a rigorous performance comparison of MCP server implementations spanning 3.9 million total requests across three independent test rounds. The benchmark evaluated four implementations under identical conditions:</p> <ul> <li>Java \u2014 Spring Boot 4.0.0 + Spring AI 2.0.0-M2 on Java 21</li> <li>Go \u2014 Official MCP SDK v1.2.0</li> <li>Node.js \u2014 @modelcontextprotocol/sdk v1.26.0</li> <li>Python \u2014 FastMCP 2.12.0+ with FastAPI 0.109.0+</li> </ul> <p>Each server was tested with 50 concurrent virtual users over 5-minute sustained runs in Docker containers (1-core CPU, 1GB memory) on Ubuntu 24.04.3 LTS. Four standardized benchmark tools measured CPU-intensive, I/O-intensive, data transformation, and latency-handling scenarios \u2014 all with a 0% error rate across every implementation.</p>"},{"location":"blog/2026/02/15/java-leads-mcp-server-performance-benchmarks-with-sub-millisecond-latency/#javas-performance-highlights","title":"Java's Performance Highlights","text":"<p>The results speak for themselves:</p> Server Avg Latency Throughput (RPS) CPU Efficiency (RPS/CPU%) Java 0.835 ms 1,624 57.2 Go 0.855 ms 1,624 50.4 Node.js 10.66 ms 559 5.7 Python 26.45 ms 292 3.2 <pre><code>---\nconfig:\n    xyChart:\n        width: 700\n        height: 400\n    themeVariables:\n        xyChart:\n            backgroundColor: transparent\n---\nxychart-beta\n    title \"Average Latency Comparison (milliseconds)\"\n    x-axis [Java, Go, \"Node.js\", Python]\n    y-axis \"Latency (ms)\" 0 --&gt; 30\n    bar [0.84, 0.86, 10.66, 26.45]</code></pre> <p>Java achieved the lowest average latency at 0.835 ms \u2014 edging out Go's 0.855 ms \u2014 while matching its throughput at 1,624 requests per second. Where Java truly stands out is CPU efficiency: at 57.2 RPS per CPU%, it extracts more performance per compute cycle than any other implementation, including Go (50.4).</p> <p>In CPU-bound workloads like Fibonacci calculation, Java excelled with a 0.369 ms response time, showcasing the JVM's highly optimized just-in-time compilation.</p>"},{"location":"blog/2026/02/15/java-leads-mcp-server-performance-benchmarks-with-sub-millisecond-latency/#a-clear-performance-tier","title":"A Clear Performance Tier","text":"<p>The benchmark reveals two distinct performance tiers:</p> <ul> <li>High-performance tier: Java and Go deliver sub-millisecond latencies and 1,600+ RPS</li> <li>Standard tier: Node.js (12x slower) and Python (31x slower) trail significantly</li> </ul> <p>Java's throughput is 2.9x higher than Node.js and 5.6x higher than Python. For latency-sensitive MCP deployments, the difference is even more pronounced \u2014 Java responds 12.8x faster than Node.js and 31.7x faster than Python.</p>"},{"location":"blog/2026/02/15/java-leads-mcp-server-performance-benchmarks-with-sub-millisecond-latency/#what-this-means-for-mcp-developers","title":"What This Means for MCP Developers","text":"<p>For teams building production MCP servers that need to handle high concurrency and low-latency tool interactions, Java with Spring Boot and Spring AI provides a battle-tested, high-performance foundation. The JVM's mature ecosystem, strong typing, and proven scalability make it an excellent choice for enterprise MCP deployments where performance and reliability are paramount.</p> <p>The full benchmark details, methodology, and raw data are available at TM Dev Lab.</p>"},{"location":"blog/archive/2026/","title":"2026","text":""},{"location":"blog/category/performance/","title":"Performance","text":""},{"location":"blog/category/benchmarks/","title":"Benchmarks","text":""}]}